import type {
  OsvQueryResponse,
  OsvVulnerability,
  OsvSeverityLevel,
  VulnerabilitySummary,
} from '#shared/types'
import { resolveDependencyTree, type DependencyDepth } from './dependency-resolver'

// Re-export for component type imports
export type { DependencyDepth } from './dependency-resolver'

/**
 * Vulnerability info for a single package in the tree
 */
export interface PackageVulnerabilityInfo {
  name: string
  version: string
  /** Depth in dependency tree: root (0), direct (1), transitive (2+) */
  depth: DependencyDepth
  vulnerabilities: VulnerabilitySummary[]
  counts: {
    total: number
    critical: number
    high: number
    moderate: number
    low: number
  }
}

/**
 * Result of vulnerability tree analysis
 */
export interface VulnerabilityTreeResult {
  /** Root package name */
  package: string
  /** Root package version */
  version: string
  /** All packages with vulnerabilities in the tree */
  vulnerablePackages: PackageVulnerabilityInfo[]
  /** Total packages analyzed */
  totalPackages: number
  /** Aggregated counts across all packages */
  totalCounts: {
    total: number
    critical: number
    high: number
    moderate: number
    low: number
  }
}

/**
 * Query OSV for vulnerabilities in a package
 */
async function queryOsv(
  name: string,
  version: string,
  depth: DependencyDepth,
): Promise<PackageVulnerabilityInfo | null> {
  try {
    const response = await $fetch<OsvQueryResponse>('https://api.osv.dev/v1/query', {
      method: 'POST',
      body: {
        package: { name, ecosystem: 'npm' },
        version,
      },
    })

    const vulns = response.vulns || []
    if (vulns.length === 0) return null

    const counts = { total: vulns.length, critical: 0, high: 0, moderate: 0, low: 0 }
    const vulnerabilities: VulnerabilitySummary[] = []

    const severityOrder: Record<OsvSeverityLevel, number> = {
      critical: 0,
      high: 1,
      moderate: 2,
      low: 3,
      unknown: 4,
    }

    const sortedVulns = [...vulns].sort(
      (a, b) => severityOrder[getSeverityLevel(a)] - severityOrder[getSeverityLevel(b)],
    )

    for (const vuln of sortedVulns) {
      const severity = getSeverityLevel(vuln)
      if (severity === 'critical') counts.critical++
      else if (severity === 'high') counts.high++
      else if (severity === 'moderate') counts.moderate++
      else if (severity === 'low') counts.low++

      vulnerabilities.push({
        id: vuln.id,
        summary: vuln.summary || 'No description available',
        severity,
        aliases: vuln.aliases || [],
        url: getVulnerabilityUrl(vuln),
      })
    }

    return { name, version, depth, vulnerabilities, counts }
  } catch {
    return null
  }
}

function getVulnerabilityUrl(vuln: OsvVulnerability): string {
  if (vuln.id.startsWith('GHSA-')) {
    return `https://github.com/advisories/${vuln.id}`
  }
  const cveAlias = vuln.aliases?.find(a => a.startsWith('CVE-'))
  if (cveAlias) {
    return `https://nvd.nist.gov/vuln/detail/${cveAlias}`
  }
  return `https://osv.dev/vulnerability/${vuln.id}`
}

function getSeverityLevel(vuln: OsvVulnerability): OsvSeverityLevel {
  const dbSeverity = vuln.database_specific?.severity?.toLowerCase()
  if (dbSeverity) {
    if (dbSeverity === 'critical') return 'critical'
    if (dbSeverity === 'high') return 'high'
    if (dbSeverity === 'moderate' || dbSeverity === 'medium') return 'moderate'
    if (dbSeverity === 'low') return 'low'
  }

  const severityEntry = vuln.severity?.[0]
  if (severityEntry?.score) {
    const match = severityEntry.score.match(/(?:^|[/:])(\d+(?:\.\d+)?)$/)
    if (match?.[1]) {
      const score = parseFloat(match[1])
      if (score >= 9.0) return 'critical'
      if (score >= 7.0) return 'high'
      if (score >= 4.0) return 'moderate'
      if (score > 0) return 'low'
    }
  }

  return 'unknown'
}

/**
 * Analyze entire dependency tree for vulnerabilities.
 */
export const analyzeVulnerabilityTree = defineCachedFunction(
  async (name: string, version: string): Promise<VulnerabilityTreeResult> => {
    // Resolve all packages in the tree with depth tracking
    const resolved = await resolveDependencyTree(name, version, { trackDepth: true })

    // Convert to array for OSV querying
    const packages = [...resolved.values()]

    // Query OSV for all packages in parallel batches
    const vulnerablePackages: PackageVulnerabilityInfo[] = []
    const batchSize = 10

    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize)
      const results = await Promise.all(
        batch.map(pkg => queryOsv(pkg.name, pkg.version, pkg.depth!)),
      )

      for (const result of results) {
        if (result) {
          vulnerablePackages.push(result)
        }
      }
    }

    // Sort by depth (root → direct → transitive), then by severity
    const depthOrder: Record<DependencyDepth, number> = { root: 0, direct: 1, transitive: 2 }
    vulnerablePackages.sort((a, b) => {
      if (a.depth !== b.depth) return depthOrder[a.depth] - depthOrder[b.depth]
      if (a.counts.critical !== b.counts.critical) return b.counts.critical - a.counts.critical
      if (a.counts.high !== b.counts.high) return b.counts.high - a.counts.high
      if (a.counts.moderate !== b.counts.moderate) return b.counts.moderate - a.counts.moderate
      return b.counts.total - a.counts.total
    })

    // Aggregate total counts
    const totalCounts = { total: 0, critical: 0, high: 0, moderate: 0, low: 0 }
    for (const pkg of vulnerablePackages) {
      totalCounts.total += pkg.counts.total
      totalCounts.critical += pkg.counts.critical
      totalCounts.high += pkg.counts.high
      totalCounts.moderate += pkg.counts.moderate
      totalCounts.low += pkg.counts.low
    }

    return {
      package: name,
      version,
      vulnerablePackages,
      totalPackages: packages.length,
      totalCounts,
    }
  },
  {
    maxAge: 60 * 60,
    swr: true,
    name: 'vulnerability-tree',
    getKey: (name: string, version: string) => `v2:${name}@${version}`,
  },
)
